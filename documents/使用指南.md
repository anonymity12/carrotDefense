# 网络对战游戏使用指南

## 快速开始

### 启动后端服务器

1. 安装依赖：
```bash
cd backend
npm install
```

2. 启动开发服务器：
```bash
npm run dev
```

服务器将在 `ws://localhost:8080` 启动。

### 使用网络客户端

#### 1. 创建客户端实例

```typescript
import { NetworkGameClient } from './src/network/NetworkGameClient';
import { PlayerRole, MessageType } from './src/network/types';

// 连接到本地服务器
const client = new NetworkGameClient('ws://localhost:8080');

// 连接
await client.connect();
```

#### 2. 注册事件监听器

```typescript
// 监听游戏状态更新
client.on(MessageType.GAME_STATE_UPDATE, (data) => {
  console.log('游戏状态:', data.state);
  // 更新UI显示
  updateGameView(data.state);
});

// 监听游戏开始
client.on(MessageType.GAME_START, (data) => {
  console.log('游戏开始！', data.config);
  // 初始化游戏界面
  initializeGame(data.config);
});

// 监听游戏结束
client.on(MessageType.GAME_OVER, (data) => {
  console.log('游戏结束！', data.winner, data.reason);
  // 显示结果
  showGameResult(data);
});

// 监听错误
client.on(MessageType.ERROR, (data) => {
  console.error('错误:', data.code, data.message);
  // 显示错误提示
  showError(data.message);
});
```

#### 3. 创建或加入房间

```typescript
// 创建房间（作为进攻方）
client.createRoom('玩家1', PlayerRole.ATTACKER);

// 或者加入现有房间（作为防守方）
client.joinRoom('房间ID', '玩家2', PlayerRole.DEFENDER);
```

#### 4. 准备开始游戏

```typescript
// 设置为准备状态
client.setReady(true);

// 当双方都准备好后，服务器会自动开始游戏
```

#### 5. 游戏操作

**进攻方操作：**

```typescript
import { VehicleType, LaneType } from './src/network/types';

// 派出有证摩托车到主道
client.spawnVehicle(VehicleType.MOTORCYCLE_WITH_PERMIT, LaneType.MAIN_ROAD);

// 派出电动自行车到非机动车道
client.spawnVehicle(VehicleType.ELECTRIC_BIKE, LaneType.NON_MOTORIZED);
```

**防守方操作：**

```typescript
import { DefenseUnitType } from './src/network/types';

// 在位置 (5, 3) 放置辅警
client.placeDefense(DefenseUnitType.AUXILIARY, { x: 5, y: 3 });

// 升级防卫单位
client.upgradeDefense('单位ID');

// 出售防卫单位
client.sellDefense('单位ID');
```

## 完整示例：进攻方客户端

```typescript
import { NetworkGameClient } from './src/network/NetworkGameClient';
import { 
  PlayerRole, 
  MessageType,
  VehicleType,
  LaneType,
  NetworkGameState 
} from './src/network/types';

class AttackerClient {
  private client: NetworkGameClient;
  private currentState: NetworkGameState | null = null;

  constructor(serverUrl: string) {
    this.client = new NetworkGameClient(serverUrl);
    this.setupEventListeners();
  }

  async connect() {
    await this.client.connect();
    console.log('已连接到服务器');
  }

  private setupEventListeners() {
    // 房间创建成功
    this.client.on(MessageType.CREATE_ROOM, (data) => {
      console.log('房间已创建:', data.roomId);
      console.log('玩家ID:', data.playerId);
      // 可以将房间ID分享给其他玩家
    });

    // 游戏状态更新
    this.client.on(MessageType.GAME_STATE_UPDATE, (data) => {
      this.currentState = data.state;
      this.onStateUpdate(data.state);
    });

    // 游戏开始
    this.client.on(MessageType.GAME_START, (data) => {
      console.log('游戏开始！');
      this.onGameStart(data.config);
    });

    // 游戏结束
    this.client.on(MessageType.GAME_OVER, (data) => {
      console.log('游戏结束！');
      console.log('胜者:', data.winner);
      console.log('原因:', data.reason);
    });

    // 错误处理
    this.client.on(MessageType.ERROR, (data) => {
      console.error('错误:', data.message);
    });
  }

  // 创建房间并准备
  createRoomAndReady(playerName: string) {
    this.client.createRoom(playerName, PlayerRole.ATTACKER);
    // 延迟一下再设置准备状态，等待房间创建完成
    setTimeout(() => {
      this.client.setReady(true);
    }, 100);
  }

  // 游戏开始时的策略
  private onGameStart(config: any) {
    console.log('地图大小:', config.gridWidth, 'x', config.gridHeight);
    
    // 初始策略：派出一些快速车辆
    this.spawnInitialVehicles();
  }

  // 派出初始车辆
  private spawnInitialVehicles() {
    // 派出3辆电动自行车到非机动车道（便宜且难击中）
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        this.client.spawnVehicle(
          VehicleType.ELECTRIC_BIKE, 
          LaneType.NON_MOTORIZED
        );
      }, i * 1000); // 每秒派出一辆
    }
  }

  // 状态更新时的决策
  private onStateUpdate(state: NetworkGameState) {
    const budget = state.attackerBudget;
    const score = state.attackerScore;

    console.log(`预算: ${budget}, 得分: ${score}/10`);

    // 简单AI：如果预算充足，继续派车
    if (budget >= 50 && state.vehicles.length < 5) {
      // 随机选择车辆类型和车道
      this.spawnRandomVehicle();
    }
  }

  // 随机派出车辆
  private spawnRandomVehicle() {
    const vehicles = [
      VehicleType.MOTORCYCLE_WITH_PERMIT,
      VehicleType.MOTORCYCLE_WITHOUT_PERMIT,
      VehicleType.ELECTRIC_MOTORCYCLE,
      VehicleType.ELECTRIC_BIKE,
    ];

    const lanes = [
      LaneType.MAIN_ROAD,
      LaneType.AUXILIARY_ROAD,
      LaneType.NON_MOTORIZED,
    ];

    const vehicleType = vehicles[Math.floor(Math.random() * vehicles.length)];
    const lane = lanes[Math.floor(Math.random() * lanes.length)];

    this.client.spawnVehicle(vehicleType, lane);
  }

  disconnect() {
    this.client.disconnect();
  }
}

// 使用示例
async function main() {
  const attacker = new AttackerClient('ws://localhost:8080');
  
  try {
    await attacker.connect();
    attacker.createRoomAndReady('进攻方玩家');
  } catch (error) {
    console.error('连接失败:', error);
  }
}

main();
```

## 完整示例：防守方客户端

```typescript
import { NetworkGameClient } from './src/network/NetworkGameClient';
import { 
  PlayerRole, 
  MessageType,
  DefenseUnitType,
  NetworkGameState 
} from './src/network/types';

class DefenderClient {
  private client: NetworkGameClient;
  private currentState: NetworkGameState | null = null;

  constructor(serverUrl: string) {
    this.client = new NetworkGameClient(serverUrl);
    this.setupEventListeners();
  }

  async connect() {
    await this.client.connect();
    console.log('已连接到服务器');
  }

  private setupEventListeners() {
    // 加入房间成功
    this.client.on(MessageType.JOIN_ROOM, (data) => {
      console.log('已加入房间:', data.roomId);
      console.log('玩家ID:', data.playerId);
    });

    // 游戏状态更新
    this.client.on(MessageType.GAME_STATE_UPDATE, (data) => {
      this.currentState = data.state;
      this.onStateUpdate(data.state);
    });

    // 游戏开始
    this.client.on(MessageType.GAME_START, (data) => {
      console.log('游戏开始！');
      this.onGameStart(data.config);
    });

    // 游戏结束
    this.client.on(MessageType.GAME_OVER, (data) => {
      console.log('游戏结束！');
      console.log('胜者:', data.winner);
      console.log('原因:', data.reason);
    });

    // 错误处理
    this.client.on(MessageType.ERROR, (data) => {
      console.error('错误:', data.message);
    });
  }

  // 加入房间并准备
  joinRoomAndReady(roomId: string, playerName: string) {
    this.client.joinRoom(roomId, playerName, PlayerRole.DEFENDER);
    // 延迟一下再设置准备状态
    setTimeout(() => {
      this.client.setReady(true);
    }, 100);
  }

  // 游戏开始时的策略
  private onGameStart(config: any) {
    console.log('地图大小:', config.gridWidth, 'x', config.gridHeight);
    
    // 部署初始防御
    this.deployInitialDefense();
  }

  // 部署初始防御单位
  private deployInitialDefense() {
    // 在关键位置部署单位
    const positions = [
      { x: 3, y: 2 },  // 主道上
      { x: 4, y: 4 },  // 辅道上
      { x: 5, y: 6 },  // 非机动车道上
    ];

    positions.forEach((pos, index) => {
      setTimeout(() => {
        this.client.placeDefense(DefenseUnitType.AUXILIARY, pos);
      }, index * 500);
    });
  }

  // 状态更新时的决策
  private onStateUpdate(state: NetworkGameState) {
    const budget = state.defenderBudget;
    const enemyScore = state.attackerScore;

    console.log(`预算: ${budget}, 敌方得分: ${enemyScore}/10`);

    // 简单AI：如果敌方得分过高，加强防御
    if (enemyScore >= 5 && budget >= 350) {
      this.deployHeavyDefense();
    }
  }

  // 部署重型防御
  private deployHeavyDefense() {
    // 部署特警单位
    this.client.placeDefense(
      DefenseUnitType.SWAT,
      { x: 8, y: 2 }  // 靠近终点
    );
  }

  disconnect() {
    this.client.disconnect();
  }
}

// 使用示例
async function main() {
  const defender = new DefenderClient('ws://localhost:8080');
  
  try {
    await defender.connect();
    
    // 需要从进攻方获取房间ID
    const roomId = prompt('请输入房间ID:');
    if (roomId) {
      defender.joinRoomAndReady(roomId, '防守方玩家');
    }
  } catch (error) {
    console.error('连接失败:', error);
  }
}

main();
```

## 测试流程

### 本地测试（同一台电脑）

1. **启动后端服务器**
```bash
cd backend
npm run dev
```

2. **打开两个浏览器标签页**

3. **标签页1（进攻方）**
```javascript
// 在浏览器控制台执行
const attacker = new AttackerClient('ws://localhost:8080');
await attacker.connect();
attacker.createRoomAndReady('进攻方');
// 记下显示的房间ID
```

4. **标签页2（防守方）**
```javascript
// 在浏览器控制台执行
const defender = new DefenderClient('ws://localhost:8080');
await defender.connect();
defender.joinRoomAndReady('房间ID', '防守方');
```

5. **观察游戏进行**
两个标签页都会收到实时的游戏状态更新。

## 调试技巧

### 查看服务器日志
服务器会输出详细的操作日志：
```
[GameServer] 新客户端连接
[GameRoomManager] 房间 xxx 已创建
[GameEngine] 派出车辆: 电动自行车 在 非机动车道
[GameEngine] 放置单位: 辅警 在 (5, 3)
```

### 使用浏览器开发工具
1. 打开 Network 标签
2. 筛选 WS (WebSocket)
3. 查看消息收发记录

### 常见问题

**Q: 连接失败**
- 确保后端服务器正在运行
- 检查 WebSocket URL 是否正确
- 检查防火墙设置

**Q: 操作无效**
- 检查预算是否充足
- 检查操作权限（进攻方/防守方）
- 查看服务器错误日志

**Q: 游戏不开始**
- 确保两个玩家都已加入
- 确保两个玩家都设置为准备状态
- 检查角色分配（需要一个进攻方和一个防守方）

## 下一步

1. **集成 PhaserJS**: 创建可视化的游戏界面
2. **实现大厅系统**: 房间列表、玩家匹配
3. **添加聊天功能**: 玩家之间沟通
4. **数据持久化**: 保存游戏记录和统计数据
